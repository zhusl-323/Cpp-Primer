# Chapter 2 变量和基本类型

### 术语

##### 初始化

* 概念：初始化，创建变量时赋予其一个初始值。

* 注意：
    * 初始化与赋值是两个完全不同的操作。赋值是把当前值擦除，以一个新值来替代。
    * 使用未初始化的变量将带来无法预计的后果。
        * 简单可靠的方法是，初始化每一个内置类型变量。
* 性质：一般在初始化变量时，初始值会被拷贝到新建的对象中。
* 默认初始化：定义变量时未指定初值，则变量被默认初始化。
    * 对于内置类型变量：
        * 若定义在任何函数体之外，则被初始化为 `0`；
        * 定义在函数体内部，则不被初始化，其值时未定义的。
    * 每个类各自决定其初始化对象的方式。
        * 绝大多数类都支持定义对象时无需显示初始化，这样的类提供了一个合适的默认值，如：`string` 生成一个空串。

##### 声明

* 概念：声称存在一个变量、函数或是别处定义的类型。也就是使得名字为程序所知。

* 形式：一个基本数据类型，及紧随的声明符列表

* 性质：

    * 一个文件若想使用别处定义的名字，则必须包含对该名字的声明

    * 使用变量前，必须声明其类型；变量可以被多次声明

    * ```c++
        extern int i;	// 声明 i
        ```

##### 定义

* 概念：为某一特定类型的变量申请存储空间

* 性质 ：

    * 定义申请了存储空间，且可能会为变量赋初值

    * 变量能且只能被定义一次，绝不能重复定义

    * 任何包含显示初始化的声明，即成为定义



类型：类型规定了其对象的存储要求和所能执行的操作。

* 算数类型：布尔值、字符、整数、浮点数等内置类型

byte：字节，内存中可寻址的最小单元；内存中的每个字节与一个 “地址” 关联。

word：字，存储的基本单元；在指定机器上进行整数运算的自然单位

object：对象，内存的一块区域，且具有某种类型；变量是命名了的对象。

静态类型：C++ 是一种静态类型语言，其含义是在编译阶段检查类型

标识符：由字母、数字、下画线组成，且必须以字母或下画线开头。

复合类型：基于其他类型定义的类型，如：引用、指针

空指针：用字面值 `nullptr` 初始化的指针

`void*`：是一种特殊的指针类型，可用于存放任意对象的地址，但不能直接操作其所指的对象。

常量表达式：值不会改变，且在编译过程就能得到计算结果的表达式

* 声明为 `constexpr` 的变量一定是一个常量，且必须用常量表达式初始化

* 字面值类型，如算术类型、引用和指针
    * 字面值为不能改变的值，如数字、字符、字符串
* 定义于函数体之外的对象，其地址固定不变，可用于初始化 `constexpr` 指针

转义序列：以 `\` 开始；

泛化的转义序列：`\x` 后跟 1 或多个十六进制数字，或 `'\'` 后跟 1~3 个八进制数字

未定义：C++ 语言未明确规定的情况。

* 未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题。



 `char ` 型：`char ` 与 `signed char` 不同，`char ` 由编译器决定表现为 `signed char` 还是 `unsigned char`。

类型选择经验准则：

* 明确知晓数值不可能为负时，选用无符号类型；
* 整数运算使用 `int`，若数值超过 `int` 范围，选用 `long long`；
* 浮点数运算使用 `double`；
* 算数表达式中不要使用 `char` 或 `bool`；

类型转换：

* 非 `bool` 的算数值赋给 `bool` 时，初始值为 `0`，则结果为 `false`；否则结果为 `true`；

* 浮点数赋给整数类型时，做截断处理；
* 赋给无符号类型超出其范围的值时，结果时初始值对无符号类型表示数值总数取模后的余数
    * 如：将 -1 赋给 `unsigned char`，结果为 -1 对 256 取模，得 255

表达式：

* 当算数表达式中既有 `unsigned` 又有 `signed` 时，`signed` 会自动转换为 `unsigned`
* 循环时若使用无符号数作为游标，注意无符号数不会小于 `0`

字面值常量：

* 整形字面值：

    * 以 `0` 开头，代表八进制数；

    * 以 `0X` 或 `0x` 开头，代表十六进制数；

* 字符字面值，如：`'a'`

* 字符串字面值，如：`"C++"`

    * 注意：结尾处有一个空字符 `'\0'`



***



### 引用

概念：引用为对象起了另外一个名字，引用类型引用另外一种类型；

* 定义引用时，程序把引用和其初始值绑定在一起；
    * 引用只能绑定在对象上，不能绑定字面值或某表达式计算结果
    * 由于引用不可重新绑定另一对象，因此引用必须初始化
* 引用即别名；
* 引用并非对象；而指针是一个对象

指针的引用，如：

```C++
int i = 42;
int *p;
int *&r = p;	// 从右向左阅读，r 是一个引用，引用的是一个 int 指针
r = &i;			// 即令 p 指向 i
```



### `const`

* 因为 `const` 对象一旦创建后其值就不能再改变，所以 `const` 必须初始化。
* 编译器将在编译过程中，把用到 `const` 变量的地方都替换成对应的值；
* 默认状态下，`const` 对象仅在文件内有效
    * 若想在多文件间共享 `const` 对象，必须在变量定义前添加 `extern` 关键字

对常量的引用：也称为 “常量引用”

* 将引用绑定到 `const` 对象上，如：

    * ```c++
        const int ci = 1024;
        const int &r1 = ci;			// r1 为对常量的引用
        ```

* 允许为一个常量引用绑定非常量的对象、字面值，甚至表达式，如：

    * ```c++
        int i = 32;
        const int &r2 = i;			// 允许
        const int &r3 = 64;			// 常量引用
        const int &r4 = r2 * 2;		// 常量引用
        ```

    * 对于上述第 2 行，编译器的解释：

        * ```c++
            const int temp = i;
            const int &r2 = temp;	// r2 绑定了一个临时量 (对象)
            ```

指向常量的指针，不能改变其所指对象的值，如：

* ```c++
    const double pi = 3.14;
    const double *cptr = &pi;			// 指向常量的指针
    ```

* 允许令一个指向常量的指针，指向一个非常量对象：

    * ```c++
        double dval = 1.77;
        const double *cptr2 = &dval;	// 指向常量的指针
        ```

常量指针，其值永不改变，且必须初始化，如：

* ```c++
    int i = 0;
    int *const cptr3 = &i;	// 从右向左读，cptr3 是一个常量，* 表示其为指针，
    						// 该常量指针指向 int 对象；cptr3 将始终指向 i
    ```

顶层 `const` 与底层 `const`

* 背景：指针本身是否为常量，以及指针所指的是否为常量

* 顶层 `const` 表示指针本身是常量；底层 `const` 表示指针所指对象是常量

    * 更一般的，顶层 `const` 可表示任意对象是常量

    * ```c++
        int j = 0;
        int *const p = &i;		// 顶层 const，常量指针
        const int cj = 24;		// 顶层 const
        const int *p2 = &cj;	// 底层 const，指向常量的指针
        const int &r = cj;		// 底层 const，用于声明引用的 const 都是底层 const
        ```



类型别名：

* 定义类型别名：

    * ```c++
        typedef double wages;	// wages 是 double 的同义词
        using wages = double;	// 与上等效
        ```

    * ```c++
        typedef char *pstring;		// pstring 为 char * 的别名，即指向 char 的指针
        const pstring cstr = 0;		// 指向 char 的常量指针
        ```

`auto` 类型说明符：

* `auto` 让编译器通过初始值来推算变量类型
* `auto` 一般会忽略顶层 `const`，保留底层 `const`

`decltype` 类型说明符：从变量或表达式的类型，推断出要定义的变量类型

* `decltype` 选择并返回操作数的数据类型。
    * 此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值

* `decltype((variable))` 的结果永远是引用 



***



变量命名规范：

* 变量名使用小写，如：`index`
* 自定义的类名一般以大写字母开头，如：`Sales_item`
* 标识符的单词间应有明显区分，如：`student_loan` 或 `studentLoan`

指针声明与定义的写法，如：

* ```C++
    int *p1, *p2;
    ```

建议：

* 在变量首次被使用时，再定义它
* 初始化所有指针

* 分开定义类及对象：

    * ```c++
        struct Sales_data {
            /* ... */ 
        };
        
        Sales_data accum, trans, *salesptr;
        ```

* 类通常被定义在头文件中，且类所在头文件的名字应与类名相同

* 使用头文件保护符，防止头文件被某文件重复包含：

    * ```c++
        #ifndef SALES_DATA_H
        #define SALES_DATA_H	// 预处理变量的名字全部大写
        	/* ... */
        #endif
        ```

全局作用域本身没有名字，如使用某全局变量时：`::reused`